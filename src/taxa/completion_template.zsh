#compdef taxa

# taxa zsh completion script
# Generated by 'taxa completion install'

# Load completion cache
_taxa_load_cache() {
  local database_name="${1:-flora}"
  local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}"
  local cache_file="${cache_dir}/taxa/completion-cache-${database_name}.json"

  # Check if jq is available
  if ! command -v jq &> /dev/null; then
    # jq not found, skip dynamic completions
    return 1
  fi

  # Check if cache exists
  [[ -f "$cache_file" ]] || return 1

  # Load arrays from cache
  # Use @ flag to split on newlines, f flag to read lines into array
  typeset -ga _taxa_taxon_names
  typeset -ga _taxa_region_keys
  typeset -ga _taxa_ranks

  _taxa_taxon_names=("${(@f)$(jq -r '.taxon_names[]' "$cache_file" 2>/dev/null)}")
  _taxa_region_keys=("${(@f)$(jq -r '.region_keys[]' "$cache_file" 2>/dev/null)}")
  _taxa_ranks=("${(@f)$(jq -r '.ranks[]' "$cache_file" 2>/dev/null)}")

  return 0
}

# Check cache freshness and trigger background regeneration if needed
_taxa_refresh_cache() {
  local database_path="${1:-flora.db}"
  local database_name="$(basename "$database_path" .db)"
  local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}"
  local cache_file="${cache_dir}/taxa/completion-cache-${database_name}.json"

  # If database doesn't exist, nothing to do
  [[ -f "$database_path" ]] || return 1

  # If cache doesn't exist, try to generate it in background
  if [[ ! -f "$cache_file" ]]; then
    (taxa completion generate-cache --database "$database_path" &>/dev/null &)
    return 1
  fi

  # Check if database is newer than cache
  if [[ "$database_path" -nt "$cache_file" ]]; then
    # Database modified, regenerate cache in background
    (taxa completion generate-cache --database "$database_path" &>/dev/null &)
  fi

  return 0
}

_taxa() {
  local -a commands
  commands=(
    'sync:Sync data from iNaturalist API to database'
    'query:Run SQL query or open interactive shell'
    'search:Search for iNaturalist IDs'
    'info:Show database info and stats'
    'breakdown:Break down taxon into hierarchical levels'
    'completion:Manage shell completions'
  )

  _arguments -C \
    '1: :->command' \
    '*:: :->args'

  case $state in
    command)
      _describe 'command' commands
      ;;
    args)
      case ${words[1]} in
        sync)
          _taxa_sync
          ;;
        query)
          _taxa_query
          ;;
        search)
          _taxa_search
          ;;
        info)
          _taxa_info
          ;;
        breakdown)
          _taxa_breakdown
          ;;
        completion)
          _taxa_completion
          ;;
      esac
      ;;
  esac
}

# Subcommand completions

_taxa_sync() {
  _arguments \
    '1:config file:_files -g "*.yaml"' \
    '--timeout[Timeout in seconds]:timeout:' \
    '--dry-run[Estimate only, do not fetch/store]'
}

_taxa_query() {
  _arguments \
    '1:query:' \
    '--database[Database file path]:database:_files -g "*.db"' \
    '-d[Database file path]:database:_files -g "*.db"'
}

_taxa_search() {
  local -a search_commands
  search_commands=(
    'places:Search for place IDs'
    'taxa:Search for taxon IDs'
  )

  _arguments -C \
    '1: :->search_command' \
    '*:: :->search_args'

  case $state in
    search_command)
      _describe 'search command' search_commands
      ;;
    search_args)
      _arguments '1:query:'
      ;;
  esac
}

_taxa_info() {
  _arguments \
    '--database[Database file path]:database:_files -g "*.db"' \
    '-d[Database file path]:database:_files -g "*.db"'
}

_taxa_breakdown() {
  local database_path="flora.db"

  # Extract database path from command line if specified
  local i
  for ((i=2; i<=$#words; i++)); do
    if [[ "${words[$i]}" == "--database" ]] || [[ "${words[$i]}" == "-d" ]]; then
      database_path="${words[$((i+1))]}"
      break
    fi
  done

  # Attempt to refresh cache (non-blocking)
  _taxa_refresh_cache "$database_path"

  # Load cache
  local database_name="$(basename "$database_path" .db)"
  _taxa_load_cache "$database_name"

  _arguments \
    '1:taxon name:_taxa_complete_taxon' \
    '--levels[Comma-separated list of taxonomic levels]:levels:_taxa_complete_ranks' \
    '--region[Filter to specific region]:region:_taxa_complete_regions' \
    '--database[Database file path]:database:_files -g "*.db"' \
    '-d[Database file path]:database:_files -g "*.db"'
}

# Completion functions for dynamic data

_taxa_complete_taxon() {
  if (( ${#_taxa_taxon_names} > 0 )); then
    _describe 'taxon name' _taxa_taxon_names
  fi
}

_taxa_complete_regions() {
  if (( ${#_taxa_region_keys} > 0 )); then
    _describe 'region' _taxa_region_keys
  fi
}

_taxa_complete_ranks() {
  if (( ${#_taxa_ranks} > 0 )); then
    # For --levels, user can enter comma-separated list
    # This is a simplified completion - just suggest ranks
    _describe 'rank' _taxa_ranks
  fi
}

_taxa_completion() {
  local -a completion_commands
  completion_commands=(
    'generate-cache:Generate completion cache from database'
    'install:Install shell completion for taxa'
  )

  _arguments -C \
    '1: :->completion_command' \
    '*:: :->completion_args'

  case $state in
    completion_command)
      _describe 'completion command' completion_commands
      ;;
    completion_args)
      case ${words[1]} in
        generate-cache)
          _arguments \
            '--database[Database file path]:database:_files -g "*.db"' \
            '-d[Database file path]:database:_files -g "*.db"'
          ;;
        install)
          _arguments '--shell[Shell type]:shell:(zsh)'
          ;;
      esac
      ;;
  esac
}

_taxa "$@"
